"""
question_sub_chain_v3.py - 

Author: cavit
Date: 2025/3/13
"""
import json
import re
from base_llm import llm_invoke
from loguru import logger
from retriver_sql_generate import name_retriever

def question_unsub_box(question):
    ret = """
    问题： {question}
    ```jsonlines
    {{"步骤":"1","子问题":{question},"是否依赖": false}}
    ```
    """.format(question=question)
    return ret

# TODO
#  #
#  # 可以使用 deepseek think 部分 进行RAG 拆解 question + prompt --> deepseek --> think and answer ---> if answer true save think
#  #  new question  --> old question match --> ds - think -- few shot --> answer
def action_sub_chain(question):
    # 生成 动作类查询思维链，注意 时间点或者时间段，时间点是精确时间，时间段是连续的时间片段
    # 先整理不用拆解的情况
    query_documents = name_retriever.get_relevant_documents(question)
    query_match_document ="\n".join([question_unsub_box(i.metadata["问题"])  for i in query_documents])
    system_prompt = """
    你现在是一个船舶AI助手，用户的问题进行拆分和
    你能根据谓词逻辑和问题的计算逻辑进行问题拆分，多问题聚合问题拆分成子问题解决；
    字段说明： 
        "步骤"：表示当前子问题进行的步骤，
        "子问题"：对子问题进行文字描述
        "依赖问题": 求解子问题需要的前提条件（前提问题）
        "是否依赖": 如果依赖之前回答填写 true，如果不依赖上下文即可回答，填写false
        "是否仅汇总": 如果该步骤只是将之前子问题的结果进行加、减、乘、除等汇总处理，则填写 true 否则填写 false
        
    首先，回顾用户提供的工具函数和表结构。用户有多个函数如 
    meta_device_info_solver： 计算设备属性信息。
    meta_device_solver：计算船舶设备运行信息。
    meta_sql_solver： 通常数据据查询。
    meta_energy_solver: 计算能耗相关问题（能耗、做功、发电量、油耗、理论发电量）
    用于处理SQL生成、数据查询和结果处理。还有多个设备相关的表，如Ajia_plc_1、task_action等，存储设备数据和动作记录。
    用户希望拆解问题时，各步骤之间避免大数据传输，可能意味着每个子问题应尽量独立，减少依赖前序步骤的大量数据结果。可能需要通过生成精确的SQL语句，直接在数据库层面处理数据聚合，而不是将中间结果传回应用层处理。
    接下来，考虑用户提供的通用拆解逻辑。之前的步骤包括解析时间、设备、参数、处理复合条件、数据质量检查和最终输出。但可能在这些步骤中存在数据传输，比如步骤之间传递查询结果，特别是当需要前序依赖时，可能需要中间数据。
    优化点可能在于：将更多处理逻辑下推到SQL查询中，利用数据库的聚合和计算能力，减少在应用层处理的数据量。例如，在步骤中直接生成包含必要聚合的SQL，使得每个子问题的结果已经是精简后的数据，减少传输量。
    同时，需要注意问题之间的依赖关系。如果某个子问题确实需要前序结果，应确保前序步骤生成的是最小必要数据，如时间范围或设备标识，而不是整个数据集。例如，步骤1确定时间范围后，步骤2使用该时间范围直接查询相关设备数据，而不需要传递具体的时间点数据。
    另外，利用数据库的临时表或CTE（公用表表达式）来处理多步骤查询，可能有助于在数据库内部维护中间结果，避免多次传输。但用户可能希望避免使用临时存储，因此需要设计自包含的SQL语句。
    还需要考虑如何将复杂条件分解为多个SQL查询，每个查询处理一个子问题，但通过参数传递关键信息，如时间戳或设备ID，而不是传递整个数据集。例如，步骤1生成动作时间，步骤2使用该时间点进行关联查询，但通过WHERE条件中的时间范围来实现，而不是传递具体的时间值。
    最后，确保每个子问题的SQL查询都是高效的，利用索引和优化查询结构，减少数据库的负载和响应时间，从而提升整体处理速度。
    案例：
    请计算2024/1/23 0:00 ~ 2024/1/25 0:00 甲板设备能耗？
    ```jsonlines
    {"步骤":"1","子问题":"请计算2024/1/23 0:00 ~ 2024/1/25 0:00 甲板设备能耗？","依赖问题":false,"是否仅汇总": false}
    ```
    在2024年6月1日深海作业A过程中，请输出两次小艇落座的时间（以XX:XX格式输出，时间为24小时制，时间补零，如05:03），以及在这两次落座期间四台发电机的总发电量（数据来源于传感器记录，单位为kWh，结果保留两位小数）。如果遇到数据缺失或异常情况，请根据相邻数据点进行合理估算。如果当天发生多次小艇落座，请仅考虑第一次和最后一次落座。
    ```jsonlines
    {"步骤":"1","子问题":"在2024年6月1日深海作业A过程中，请输出两次小艇落座的时间（以XX:XX格式输出，时间为24小时制，时间补零，如05:03，如果当天发生多次小艇落座，请仅考虑第一次和最后一次落座。","是否依赖": false,"是否仅汇总": false}
    {"步骤":"2","子问题":"基于步骤 1，以及在这两次落座期间四台发电机的总发电量（数据来源于传感器记录，单位为kWh，结果保留两位小数）。如果遇到数据缺失或异常情况，请根据相邻数据点进行合理估算。","是否依赖":true,"是否仅汇总": false}
    ```
    
    请统计2024年1月1日至1月31日期间，深海作业A的次数（一个完整的布放过程加一个完整的回收过程算作一次作业；如果存在只有布放或只有回收的情况，不计算在内）
    /**
    解释： sql语句中，只要计算当天是否进行过下放并且进行过回收，即可判断是否进行深海作业A，可以直接返回count(1) 所以不必进行问题拆解
    **/
    ```jsonlines
    {"步骤":"1","子问题":"请统计2024年1月1日至1月31日期间，深海作业A的次数（一个完整的布放过程加一个完整的回收过程算作一次作业；如果存在只有布放或只有回收的情况，不计算在内）","是否依赖":false,"是否仅汇总": false}
    ```
    
    请告诉我 XXX日 A架摆出动作、A架摆回时间点,在这个两个时间点之间，四台发电机的发电量（如果有有多个时间点去第一个时间点和最后一个时间点进行计算）
    /**
    解释： 动作时间点计算 不需要拆解， 计算时间点内油耗能耗等其他指标 需要先提取出时间点
    **/
    ```jsonlines
    {"步骤":"1","子问题":"请告诉我 XXX日 A架摆出动作、A架摆回时间点。","是否依赖":false,"是否仅汇总": false}
    {"步骤":"2","子问题":"根据步骤1的时间点（如果有有多个时间点去第一个时间点和最后一个时间点），计算这个时间段内四台柴油发电机的发电量是多少","是否依赖": true,"是否仅汇总": false}
    ```  
    
    请告诉我xxx日期 渡航状态持续多久，期间甲板设备能耗
    ```jsonlines
    {"步骤":"1","子问题":"请告诉我xxx日期，渡航状态持续多久","是否依赖":false,"是否仅汇总": false}
    {"步骤":"2","子问题":"根据步骤1的时间点，计算这个时间段的甲板设备能耗","是否依赖": true,"依赖问题":"xxx日期 渡航状态的时间点（开始时间、结束时间）","是否仅汇总": false}
    ```

    请告诉我xxx日期 停泊状态持续多久，期间甲板设备能耗
    ```jsonlines
    {"步骤":"1","子问题":"请告诉我xxx日期 停泊状态持续多久","是否依赖":false}
    {"步骤":"2","子问题":"根据步骤1的时间点，计算这个时间段的甲板设备能耗","是否依赖": true,"依赖问题":"xxx日期 停泊状态的时间点（开始时间、结束时间）","是否仅汇总": false}
    ```
    请告诉我xxx日期 动力定位持续多久，期间甲板设备能耗
    ```jsonlines
    {"步骤":"1","子问题":"请告诉我xxx日期 动力定位持续多久","是否依赖":false}
    {"步骤":"2","子问题":"根据步骤1的时间点，计算这个时间段的甲板设备能耗","是否依赖": true,"依赖问题":"xxx日期 动力定位状态的时间点（开始时间、结束时间）","是否仅汇总": false}
    ```
    请告诉我xxx日期 伴航状态持续多久？，期间甲板设备能耗
    ```jsonlines
    {"步骤":"1","子问题":"请告诉我xxx日期 伴航状态持续多久？","是否依赖":false}
    {"步骤":"2","子问题":"根据步骤1的时间点，计算这个时间段的甲板设备能耗","是否依赖": true,"依赖问题":"xxx日期 伴航状态的时间点（开始时间、结束时间）","是否仅汇总": false}
    ```
    
    以下是问题拆解的粒度，这些问题能够直接使用sql进行解决，子问题拆解到该问题粒度，就不再进行拆解（尽量不要对问题进行拆解，拆解原则是单独单独子问题，以及能耗类问题可以拆解）：
    """
    system_prompt = system_prompt  + query_match_document + "\n"
    system_prompt += """
    能耗类拆解规则：
    如果给定柴油的密度，柴油热值和具体时间，及n号发电机计算理论发电量，则不用拆分
    如果给定具体时间和n号发电机计算油耗或者发电量不用拆分
    如果给定具体时间和设备求功耗能耗则不用拆分
    例如：
    24年3月25日发电机油耗是多少？
    /**
    默认4台发电机，具体时间和计算要求充分 不必拆分出子问题
    **/
    ```jsonlines
    {"步骤":"1","子问题":"24年3月25日发电机油耗是多少？","是否依赖":false,"是否仅汇总": false}
    ```
    24年3月25日A架摆出和A架摆回期间发电机油耗是多少？
    /**
    需要具体时间需要求出 A架摆出和A架摆回时间点，所以需要拆分成2个子问题
    **/
    ```jsonlines
    {"步骤":"1","子问题":"24年3月25日A架摆出和A架摆回时间点","是否依赖":false}
    {"步骤":"2","子问题":"根据步骤1，24年3月25日A架摆出和A架摆回时间点期间，发电机油耗是多少？","是否依赖":true,"依赖问题":"24年3月25日A架摆出和A架摆回时间点","是否仅汇总": false}
    ```
    24年3月25日xx过程中，发电机油耗是多少？
    /**
    xx过程 xx状态隐藏条件未 xx开始时间 和 xx结束时间，例如A架开机过程 暗含A架开机和A架关机
    渡航过程，停泊过程，dp状态等都是xx过程，只要未给出明确时间 则需要拆分出子问题
    **/
    ```jsonlines
    {"步骤":"1","子问题":"24年3月25日xx过程，开始时间点和结束时间点","是否依赖":false}
    {"步骤":"2","子问题":"根据步骤1，24年3月25日xx过程，开始时间点和结束时间点，发电机油耗是多少？","是否依赖":true,"依赖问题":"24年3月25日xx过程，开始时间点和结束时间点","是否仅汇总": false}
    ```
    """
    user_prompt = f"""
    请将下列问题进行拆解：
    ================
    {question}
    ================
    注意：
    一、不必太过在意问题括号中的说明（如果说明中有特殊情况，再按照特殊说明进行拆解）。
    二、原则上问题通常不拆解，除非遇到能耗问题（能耗、油耗、发电量、理论发电量之类的）和资料类问题以及先判断时间点再根据时间点进行查询计算问题，只有这三种情况需要拆解。
       涉及到时间点问题包括： 
       1、两个作业动作时间点，例如： A架摆出和小艇落座时间内XXXX 
       2、渡航状态、停泊状态、动力定位状态、伴航状态 都是先求出时间点 例如渡航状态为： xx日期 渡航开始时间到渡航结束时间 XXX 
       3、动作时间点都需要求解，不要在子问题中生成 XX时间点,XX情况的问题，而是采用 根据步骤n得到时间点 计算 xxxx
    三、通常最后一个步骤为回答步骤,如果格式转化要求中包含json结构，则说明按照原问题的json格式要求即可（移除子问题内容中的\n，子问题中的如果涉及双引号，替换为单引号）
    四、回答结果仅仅是通过之前步骤结果进行 简单加减乘除的情况(不进行其他操作，仅根据之前结果进行简单计算) ,"是否仅汇总" 才填写 true, 其他一律都是 false
    """
    messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": user_prompt}
    ]
    response = llm_invoke(messages)

    def extract(content):
        # 匹配 ```jsonlines 包裹的内容
        match = re.search(r'```jsonlines\n(.*?)\n```', content, re.DOTALL)
        if not match:
            return None

        str_data = match.group(1)

        r = []

        # 按行分割处理
        for line in str_data.strip().split('\n'):
            line = line.strip()
            if not line:
                continue
            try:
                # 解析每行的JSON对象
                row = json.loads(line)
                r.append(row)
            except json.JSONDecodeError:
                # 解析失败时返回None
                return None

        return r

    return extract(response)

if __name__ == '__main__':
    question = "统计 2024/08/24 - 2024/08/29 期间，“征服者”在 09:00:00 之前 入水的比例（%，以所有在该时间段内入水的征服者为基数，结果保留 2 位小数）。同时，统计该时间段内，四台发电机的日燃油消耗量最大的一天，以及对应的燃油消耗量（格式：MM/DD；单位：L，保留两位小数）。若有多天燃油消耗量相同，则输出最早的一天。"
    question = """2024/08/23 深海作业A过程中，A架摆回到A架摆出期间，推进器的总做功是多少（单位为kWh，结果保留两位小数）？"""
    print(action_sub_chain(question))